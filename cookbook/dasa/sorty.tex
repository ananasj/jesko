%Tu si môžete zaznačiť, že pracujete na danej veci. V prípade, že ste napísali len časť a ďalej už
%nechcete, alebo ste hotoví tak sa odtiaľ odpíšte. Bolo by však fajn, aby jedu vec robil jeden
%človek ak celok a zvyšný len kontrolovali
%vypracuva: Zaba
\input ../../include/include.tex

\begin{document}

\velkynadpis{Triedenie}

\textit{Ako správne používať tento študijný text: Milý čitateľ. Chystáš sa prečítať si kuchárku o
triedení. Počas čítania narazíš na niekoľko problémov, ktoré ti odporúčame vyriešiť. Má to dopomôcť
k tomu, aby si lepšie pochopil o čom sa rozprávame. Samozrejme nikto ti nezakazuje čítať ďalej,
vystavuješ sa tým však riziku, že si prezradíš riešenie.}

Obsah:
\begin{itemize}
    \item cieľ
    \item $n^2$ sorty
    \item $n\log n$ sorty
    \item $n$ sorty
    \item nejde to lepšie
\end{itemize}

\medskip

Ako napovedá názov textu, budeme sa rozprávať o triedení. Schopnosť zoradiť veci do poradia je totiž
veľmi dôležitá a využívaná. Však stačí, že chcete zoradiť futbalové družstvá podľa počtu bodov čo
získali. Alebo hráte karty a chcete ich mať na ruke pekne poporadí od najmenšej po najväčšiu. Pri
tomto všetkom potrebujeme usporiadať veci podľa určitej vlastnosti a od nás informatikov sa čaká, že
to budeme vedieť robiť rýchlo a efektívne a to aj pre viac ako $14$ kariet na ruke, alebo $30$ tímov
vo futbalovom rebríčku.

\medskip

Na oboznámenie sa s utriedenými postupnosťami, skúste vyriešiť úlohu \textbf{poriadok}.

\nadpis{Pomalšie triedenia}

Začnime s ľahšími (na nakódenie aj pochopenie), ale pomalšími algoritmami, riešiacimi problém
triedenia. Ten môžeme chápať nasledovne: V poli $A$ máme $n$ prvkov. Chceme preusporiadať pole $A$
tak, aby v ňom prvky boli od najmenšieho po najväčší.

Dôležité je si určiť, čo znamená najmenší prvok a vôbec operátor \texttt{menší}. Keď porovnávame
čísla, je to jasné. Používame normálne $<$, teda $2<8$, $47<212$ \dots Nie vždy však pracujeme len s
číslami. Môžeme dostať napríklad písmená. Tie môžeme porovnávať podľa poradia v abecede. Samozrejme
to nie je všetko, čo môžeme robiť. Našu operáciu \texttt{menší} si môžeme zvoliť podľa ľubovôle,
stačí aby nám dávala zmysel a po celý čas sme sa jej držali. V ďalšom texte však budeme
predpokladať, že pracujeme s celými číslami a používame normálne $<$.

\medskip

Aby som vás týmto úplne neunudil, vyriešte úlohu \textbf{vystava}.

\medskip

Prečo práve takúto úlohu? Dostať najmenší prvok na začiatok poľa a nič iné nemeniť? Vedie nás to
totiž k našému prvému triediacemu algoritmu -- \texttt{Minsort}. Jeho myšlienka je veľmi jednoduchá.
Zoberme si pole $A$ celých čísiel a chceme ho usporiadať od najmenšieho po najväčší prvok. Ktoré
číslo sa bude nachádzať na začiatku takto utriedenej postupnosti? Samozrejme, že to najmenšie. Ak by
to tak nebolo, potom by niektorá časť poľa predsa nebola utriedená. Vieme teda, čo je na prvej
pozícii výsledného poľa. Zvyšných $n-1$ čísiel, ktoré sú teraz na pozíciách $2$ až $n$ je však stále
neusporiadaných.

Tu sa však dá použiť znova tá istá myšlienka. Najmenšie číslo, ktoré je teraz na pozícii $1$ necháme
tak, to už je umiestnené dobre. Skúsime nájsť číslo na pozíciu $2$. A to bude samozrejme najmenšie
číslo z čísiel zvyšných, teda tých, čo sú na pozíciách $2$ až $n$. A takto postupujeme ďalej a
ďalej. Postupne priraďujeme čísla na prvú, druhú, tretiu až $n$-tú pozíciu a vždy ho nájdeme ako
minimum z čísiel zvyšných. Znamená to, že $n$ krát urobíte to, čo ste robili v úlohe
\textbf{vystava}, akurát na stále menšom poli. A to už predsa nie je problém.
Výsledná časová zložiťosť však bude $O(n^2)$. Nie zlé, ale stále nie najlepšie.

\medskip

Predpokladám, že teraz už bez problémov viete naprogramovať vlastný \texttt{Minsort}, môžete si to
teda hneď vyskúšať na úlohe \textbf{utried1}.

\medskip

Asi vás veľmi neprekvapivý, že na úlohu sa dá pozrieť aj opačne. Aké číslo je na poslednom mieste
zoradeného poľa. Samozrejme, že je to maximum, čo dá vznik algoritmu \texttt{Maxsort}.

\bigskip

Zostaňme ešte chvíľu pri triedeniach so zložitosťou $O(n^2)$. Na začiatku sme spomínali ukladanie
kariet. Tento proces je všetkým známi. Postupne, jednu po jedne, beriete karty z vašej kôpky a
nachádzate im príslušné miesto na ruke. Ako však nájdete miesto, kam daná karta patrí? Začnete na
konci. Porovnáte novú kartu s poslednou kartou v ruke. Ak je nová karta väčšia, rovno ju dáte na
koniec, lebo viete, že všetky ostatné karty na ruke sú od nej tiež menšie. Ak je však menšia ako
posledná karta, znamená to, že ju treba zaradiť niekam ďalej. Pozriete sa teda na predposlednú
kartu. Takto postupujete, až kým prvýkrát nie je nová karta väčšia ako karta, na ktorú sa pozeráte,
alebo ste dosiahli úplný začiatok. Na toto miesto kartu vsuniete.

Tento istý prístup sa dá simulovať aj programom. Postupne beriete čísla a máte pole, kde si ukladáte
výsledok. Postupne idete od konca poľa a sledujete, či vaše nové číslo nie je väčšie. Takto mu
nájdete správne miesto. Problém však je, že neviete toto číslo strčiť do stredu poľa tak ako kartu.
Toto môžete vyriešiť tak, že vždy keď zistíte, že nové číslo je menšie ako číslo skúmané, posuniete
toto číslo o jedna dozadu v poli. Takto si spravíte priestor pre nové číslo, ktoré tam potom viete
pohodlne vložiť. Tento algoritmus má tiež zložitosť $O(n^2)$ a volá sa \texttt{Insertsort}. Kvôli 
problematickému vsúvaniu čísiel sa nedá viac vylepšiť. Jeho naprogramovanie si tiež môžete vyskúšať
na úlohe \textbf{utried1}, dajte si však pozor, aby ste skontrolovali, či nie ste už na začiatku poľa.

Toto samozrejme nie je posledný zo série triediacich algoritmov so zložitsťou $O(n^2)$. Existuje ich
ešte o dosť viac, od šialených až po tie rozumnejšie. Nie sú však až tak dôležité, vrhnime sa preto
na algoritmy rýchlejšie.

\nadpis{Rýchle triedenia}

V tejto časti sa budeme snažiť čas výpočtu znížiť na $O(n\log n)$. K tomu budeme používať rekurziu,
ktorá bude rozdeľovať naše pole na menšie a menšie kusy, tie samostatne utriedi a nakoniec z nich
vyskladá riešenie.

Prvým z algoritmov bude \texttt{Mergesort}, teda triedenie spájaním. Tento algoritmus sa pýta, či ak
rozdelím pole na dve polky, každú z nich samostatne utriedim, či ich viem potom spojiť do jedného
výsledného utriedeného poľa.

\medskip

Pred pokračovaním čítania, kde bude postup riešenia vysvetlený, môžete sa nad tým zamyslieť sami pri
úlohe \textbf{merge}.

\medskip

Predpokladajme, že máme dve utriedené polia čísiel $A$ a $B$ a chceme ich teraz spojiť do jedného
usporiadaného poľa. Ktorý prvok môže byť na začiatku výsledného poľa? Chceme tam najmenší prvok. A
vieme, že na začiatku $A$ je najmenší prvok aj na začiatku $B$ je najmenší prvok, lebo sú utriedené.
To ale znamená, že menšie z týchto dvoch čísiel je najmenšie aj celkovo. Vieme teda prvý prvok
výsledku. Nech je to prvé číslo z $A$. Vyhodíme ho teda zo začiatku $A$ a dostávam tú istú situáciu.
Znova, ktorýkoľvek z prvkov na začiatku polí $A$ a $B$ môže byť aktuálne najmenší a teda ísť na
druhú pozíciu. Opakovaním tohoto postupu dostanem výsledného poľa.

Čo sa týka konkrétnej implementácie, samozrejme nechceme prvky z poľa vyhadzovať, lebo to zaberá
príliš veľa času. Radšej si zoberieme dve premenné $a$ a $b$, ktoré budú ukazovať na pomyselný
začiatok oboch polí. Ak teda "vyhodíme" prvok zo začiatku $A$, znamená to, že len o $1$ zväčšíme
premennú $a$. Tiež si dajte pozor, aby ste kontrolovali, či ste niektoré pole nevyčerpali celé, aby
ste nevypadli mimo pamäť.

S touto jednoduchou úvahou je už výsledný algritmus jednoduchý. Ak mám pole veľkosti $1$ alebo $2$,
toto pole viem jednoducho utriediť najviac jednou výmenou. Ak je naše pole väčšie, rozdelím ho na
dve polovice a na tie rekurzívne zavolám ten istý algoritmus. To znamená, že ich dostanem obe
utriedené a potrebujem ich spojiť. A na to použijem hore vysvetlené spájanie (merge). Na konci
dostanem utriedené celé pole.

Treba si všimnúť, že algoritmus potrebuje naviac jedno pomocné pole, kam bude mergovať výsledok. Dá
sa to síce aj bez neho, ale nie je to príjemné a pole naviac nám nijak neuškodí.

Otázkou zostáva, či je to naozaj také rýchle ako som tvrdil. Aké rýchle je naše spájanie. No
jednoducho lineárne od počtu prvkov, ktoré spájam. Predstavme si teraz čo robí náš algoritmus.
Najskôr rozdelí pole na dve polovice (to je prvá úroveň). Tie rozdelí na dokopy štyri štvrtiny
(druhá úroveň) atď. až kým nedosiahne polia veľkosti $1$. Keďže veľkosti časťí na úrovniach sa stále
delia na polovicu, znamená to, že mám približne $\log n$ úrovní. Otázkou zostáva, koľko práce
vykonám na každej úrovni. Na to si stačí všimnúť, že každý prvok pôvodného poľa je na každej úrovni
zastúpený práve raz, teda na každej úrovni je $n$ prvkov. No a na každej úrovni použijem lineárny
merge. To znamená, že spravím $O(n)$ operácií. Na $\log n$ úrovniach spravím $O(n)$ operácií, teda
výsledný čas je $O(n \log n)$.

\medskip

Svoju novonadobudnutú znalosť si hneď môžete vyskúšať na úlohe \textbf{utried2}.

\medskip

To však nie je všetko. \texttt{Mergesort} totiž nie je jediný a dokonca ani najpoužívanejší
triediaci algoritmus v čase $O(n \log n)$. To čo sa používa oveľa viac je takzvaný
\texttt{Quicksort}. Tento algoritmus sa dá totiž oveľa ľahšie naprogramovať bez pamäte naviac a
taktiež má veľmi malý počet cache-missov. Poďme sa teda pozrieť na to, čo robí. Predtým však môžete
skúsiť vyriešiť úlohu \textbf{pivot}.

Ako správne predpokládate, ani táto úloha sem nie je zaradená úplne náhodne a má s
\texttt{Quicksortom} priami súvis. Úloha znie tak, že máme pole celých čísiel $A$ a číslo $p$. Toto
číslo nazývame pivot. Našou úlohou je rozdeliť pole na tri menšie polia, čísla menšie ako $p$, čísla
rovnaké ako $p$ a čísla väčšie ako $p$. Naviac nás vôbec nezaujíma vzájomné poradie prvkov v týchto
poliach.

Riešenie je samozrejme veľmi jednoduché. Stačí postupne prechádzať naším poľom $A$ a rozdeľovať
prvky po poradí do príslušného výsledného poľa. Ako nám však toto pomôže pri triedení celého poľa
$A$. No vieme, že výsledok bude vyzerať nasledovne: najskôr pôjdu zoradené prvky menšie ako $p$,
potom prvky rovné $p$ a na záver zoradené prvky väčšie ako $p$. To znamená, že sme si našu úlohu
rozdelili opäť na dve menšie časti, na ktoré sa potrebujeme rekurzívne zavolať. Vidíme, že rozdeliť
pole podľa pivota $p$ -- zpivotizovať ho, nám trvá čas $O(n)$. A ak by sme si vybrali prvok $p$ vždy
tak, aby menšie prvky tvorili polovicu všetkých prvkov, mali by sme $\log n$ úrovní, na každej s
prácou $O(n)$, takže výsledný čas by bol $O(n \log n)$.

To je síce pekné, ale príliš optimistické. Poďme sa pozriť aj na to, ako najdlhšie môže bežať náš
algoritmus. Môžeme mať smolu a prvok $p$ si vždy vybrať ako najväčší prvok nášho neutriedeného poľa.
To znamená, že namiesto $\log n$ úrovní, budeme mať úrovní $n$. A na každej bude stále o jedna menej
prvkov. To znamená, že zložitosť bude $O(n^2)$. To ako vieme, je pre veľké polia nepoužiteľné. Čo s
tým?

Ak by sme cheli, aby náš program rozdelil pole vždy na polovice, ako prvok $p$ by sme si museli
zvoliť stredný prvok postupnosti -- medián. Pozitívne, existuje algoritmu, ktorý nájde medián v
postupnosti v čase $O(n)$. Bohužiaľ, tento algoritmus je dosť komplikovaný (môžete si o ňom prečítať
v samostatnej sekcii) a má privysokú konštantu, aby sa dal používať prakticky. To čo teda spravíme
je, že to necháme na náhodu.

Pozrime sa na to tak intuitívne. Ak vyberiem daný prvok, z ešte neutriedených prvkov, náhodne, je
predsa oveľa pravdepodobnejšie, že to bude prvok blízko stredu ako že to bude prvok maximálny.
Existuje dôkaz (bohužiaľ trochu komplikovanejší), ktorý ukáže, že v priemernom prípade je časová
zložitosť \texttt{Quicksortu} naozaj $O(n \log n)$ a je veľmi nepravdepodobné, že to bude viac. A to
naozaj úplne stačí. Dostaneme jednoduchý a rýchly algoritmus.

Môžete si aj vyskúšať naprogramovať na úlohe \textbf{utried2}. Dávam vám však do pozornosti aj náš
vzorový program. Ukazuje, ako sa dá \texttt{Quicksort} implementovať bez pomocného poľa, aj keď je
to trochu trikové, lebo sa netreba zapliesť v $\pm 1$. Určite si ho teda naštudujte.

\end{document}
